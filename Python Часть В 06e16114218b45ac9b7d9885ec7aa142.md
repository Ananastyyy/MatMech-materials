# Python. Часть В

## SPOILER B

<<<< Задание 1. (3 балла) >>>>

Как из блока `ехсерt` выбросить исключение без «приклеивания» текущего?

[[-----

```python
try:
    # CODE
except:
    raise #NEW_ERROR from None
```

----]]

<<<< Задание 2. (3 балла) >>>>

Назовите минимум 3 отличия списка от множества (как структуры данных).

[[-----

1. Список - упорядочен по времени добавления, множество - нет
2. Список может иметь дубликаты, множество - нет
3. Список поддерживает индексацию элементов, множество - нет
4. В списке можно напряму изменять элементы, в множестве - нет

----]]

<<<< Задание 3. (2 балла) >>>>

Даны два множества: `а` и `b`. Как получить множество `с`, являющееся их объединением?

[[-----

a.union(b)

----]]

<<<< Задание 4. (3 балла) >>>>

Каким стандартным средством Рythоn можно остановить выполнение запущенного потока? Если такого нет, поясните почему.

[[-----

В Python нет стандартного средства для остановки выполнения запущенного потока напрямую. Обычно в Python потоки останавливаются по достижении точки завершения или при помощи сигналов или флагов, которые позволяют потоку завершить свою работу добровольно.

Остановка потока напрямую была убрана из стандартной библиотеки Python, так как она может приводить к непредсказуемым побочным эффектам и состояниям, таким как блокировки или некорректное освобождение ресурсов.

Рекомендуется использовать другие подходы для управления выполнением потоков, такие как использование флагов или сигналов для коммуникации между потоками и передачи управления из одного потока в другой.

- ----]]

<<<< Задание 5. (2 балла) >>>>

Какие параметры принимает метод `thrоw` у генератора?

[[-----

Принимает один обязательный аргумент - исключение, которое нужно "бросить" в генератор и один необязательный - значение исключения

----]]

<<<< Задание 6. (3 балла) >>>>

В каких целях используется метод `__rерr__`? Как его обычно реализуют?

[[-----

Должен вернуть строку копия которой при вызове предоставит такой же экземпляр класса как и вызванный экземпляр. Также с его помощью можно воссоздать объект:

```python
str_obj = repr(MyClass("foo", "bar"))
print(str_obj)  # 'MyClass(\'foo\', \'bar\')'
```

Метод **`__rеpr__()`** обычно реализуется в классе, чтобы определить пользовательское строковое представление объекта.

- ----]]

<<<< Задание 7. (3 балла) >>>>

Перечислите все возможные формы вызова встроенной функции `nехt` и кратко опишите, что они делают.

[[-----

1. `next(iterator)` - возвращает следующий элемент итератора `iterator`. Если достигнут конец итерабельного объекта, то функция вызовет исключение `StopIteration`. Эта форма часто используется в циклах `while`.
2. `next(iterator, default)` - возвращает следующий элемент итератора `iterator`, но если достигнут конец итерабельного объекта, то возвращает значение `default` вместо вызова исключения `StopIteration`.
3. `obj.__next__()` - вызов этой функции эквивалентен форме `next(obj)`. Однако, чаще используют форму `next()`.
- ----]]

<<<< Задание 8. (2 балла) >>>>

Чем пакет отличается от модуля?

[[-----

Пакет – это каталог, который может включать другие каталоги или модули. Модуль может содержать функции, классы и т.д.

Таким образом, можно сказать, что пакеты в Python являются способом структурирования модулей в более высокоуровневую абстракцию, а модули - это единицы кода, которые предназначены для реализации конкретных функций. Использование пакетов позволяет сделать проект более организованным, структурированным и более легким для поддержки.

- ----]]

<<<< Задание 9. (2 балла) >>>>

Как проверить вхождение подстроки `w` в строку `s`?

Привести 3 способа, каждый способ — одно выражение на Рythоn.

[[-----

1. Оператор `in` - наиболее простой способ. Этот оператор возвращает `True`, если подстрока присутствует в строке, и `False` в противном случае.

2. Метод `find()` - этот метод возвращает индекс первого вхождения подстроки в строку (`1`, если подстрока не найдена). Если требуется найти не первое, а все вхождения, то можно использовать метод `re.findall()`

3. Метод `index()` - этот метод работает аналогично методу `find()`, но если подстрока не найдена, то вызывает исключение `ValueError`.

```python

result = True if s.index(w) >= 0 else False
```

4. Метод `startswith()` и `endswith()` - эти методы проверяют, начинается ли или заканчивается ли строка на заданную подстроку. 

5. Регулярные выражения - можно использовать для более сложных паттернов поиска подстроки в строке. Для этого нужно импортировать модуль `re` и использовать методы `search()` или `findall()`.

- ----]]

<<<< Задание 10. (2 балла) >>>>

Для каких целей нужен менеджер контекстов?

[[-----

Менеджер контекста - это блок кода, который позволяет автоматически выполнять произвольную предварительную и завершающую работу с ресурсами, такими как открытие и закрытие файлов, сетевых подключений, блокировок и т.д. Этот блок кода, определенный с помощью инструкции `with`, гарантирует, что ресурс будет надежно освобожден после завершения работы с ним, даже в случае возникновения исключений.

```python
with open("file.txt", "r") as f:
    content = f.read()
```

- ----]]

<<<< Задание 11. (2 балла) >>>>

Дана строка `s` с названием модуля. Как проверить, что он уже импортирован?

[[-----

```python
# 1)
if s in sys.modules:
    # module has been imported
else:
    # module has not been imported

# 2)
try:
    import s
    # module has been imported
except ImportError:
    # module has not been imported
```

- ----]]

<<<< Задание 12. (4 балла) >>>>

Расскажите, что происходит в коде: `imроrt m` (требуется написать действия, происходящие при выполнении данного кода).

[[-----

Интерпретатор ищёт встроенный модуль с именем m.

Если такого модуля нет, то идёт поиск файла m.py в списке директорий, определённых в переменной sys.path.

sys.path инициализируется из следующих мест:

Директории, содержащей исходный скрипт (или текущей директории, если файл не указан);

Директории по умолчанию, которая зависит от дистрибутива Python;

PYTHONPATH (список имён директорий; имеет синтаксис, аналогичный переменной окружения PATH).

GPT:

1. Интерпретатор Python проверяет, есть ли модуль `m` в списке импортированных модулей. Если модуль уже был ранее импортирован в этом сеансе интерпретатора, то импортировать его снова не будет - будет использоваться ранее созданный объект модуля.
2. Если модуль не был ранее импортирован, то Python ищет файл `m.py` в списке каталогов, указанных в переменной `sys.path`. Это список директорий, где Python ищет модуль. Сначала Python проверяет текущую директорию (где находится исполняющий скрипт или родительский модуль). Если файл `m.py` не находится в текущем каталоге, то Python ищет его в других директориях, указанных в `sys.path`.
3. Если файл `m.py` найден, то Python компилирует его в байт-код и исполняет. Инструкции в файле `m.py` добавляют новые объекты в глобальное пространство имен модуля `m`. Эти объекты могут быть переменными, функциями, классами и т.д.
4. Если в `m.py` определена переменная `__name__`, то интерпретатор Python устанавливает ее значение в строку `"m"`. Если `m.py` является запускаемым скриптом, т.е. модулем верхнего уровня, значение `__name__` будет установлено в строку `"__main__"`.
5. После завершения выполнения кода в `m.py` в глобальном пространстве имен модуля `m` будут находится все объекты, которые были определены в файле. Они могут быть использованы в других модулях с помощью инструкции "import m" или "from m import ...".

В результате импортирования модуля `m`, его функции, классы и переменные становятся доступными из текущего модуля и могут быть использованы для выполнения нужных задач.

- ----]]

<<<< Задание 13. (3 балла) >>>>

Что такое и как используется атрибут `__mrо__` у класса?

[[-----

Содержит кортеж с родительскими типами, выстроенными в порядке разрешения методов.

При определении порядка наследования.

GPT:

В Python атрибут **`__mro__`** (Method Resolution Order) является атрибутом, который используется для определения порядка разрешения методов в множественном наследовании. Он представляет собой кортеж, содержащий последовательность классов, которые интерпретатор Python будет искать при вызове методов в классе или его экземплярах. Когда вызывается метод у класса или его экземпляра, интерпретатор Python последовательно обходит классы в порядке, определенном атрибутом **`__mro__`**, и вызывает первый найденный метод с соответствующим именем. Если метод не найден ни в одном из классов, возникает исключение **`AttributeError`**. Атрибут **`__mro__`** особенно полезен при понимании порядка разрешения методов в множественном наследовании и может быть использован для явного определения порядка, в котором интерпретатор Python будет

- ----]]

<<<< Задание 14. (2 балла) >>>>

Дан объект процесса `р`. Как его завершить?

[[-----

Метод `p.kill()` посылает процессу сигнал `SIGKILL`, который принудительно убивает процесс. Этот сигнал не может быть перехвачен или обработан процессом. Процесс будет немедленно завершен, без возможности закрыть открытые файлы или выполнить другие финализирующие операции. Этот метод должен использоваться только как крайнее средство в случае, если процесс не отвечает на другие методы завершения.

Метод `p.terminate()` посылает процессу сигнал `SIGTERM`, который в общем случае просит процесс корректно завершить работу. Процесс может перехватить этот сигнал и выполнить финализирующие операции, такие как закрытие открытых файлов или освобождение других ресурсов. Однако никак не гарантируется, что процесс завершит свою работу корректно, и он может продолжать работу в фоновом режиме. Если процесс не завершает свою работу в течение некоторого времени, можно использовать метод `p.kill()`, чтобы принудительно завершить его.

- ----]]

<<<< Задание 15. (2 балла) >>>>

Какой метод нужно реализовать в классе, чтобы объект `о` данного класса можно было использовать так: `о()`?

[[-----

Чтобы объект **`о`** данного класса можно было использовать как функцию, необходимо реализовать в классе метод **`__call__()`**. Этот метод позволяет вызывать экземпляр класса, как если бы он был функцией.

```python
class MyClass:
	def __init__(self, x):
		self.x = x

	def __call__(self):
    print("x =", self.x)

o = MyClass(10)
o()  # вызываем объект o как функцию, выводит: x = 10
```

- ----]]

<<<< Задание 16. (2 балла) >>>>

Какие имеются ограничения на заглядывание назад?

[[-----

Содержащийся в нем шаблон должен соответствовать только строкам некоторой фиксированной длины, что означает,

что abc или a|b разрешены, а a* и a{3,4} нет.

GPT:

1. Фиксированная длина. В языке Python нельзя использовать переменные ограничения на длину заглядывания назад. То есть, если мы используем `(?<=abc)`, то `abc` должно иметь фиксированную длину.
2. Ограниченное число вариантов. В языке Python заглядывание назад может содержать только альтернативу из нескольких фиксированных вариантов. Например, `(?<=(foo|bar))` допустимо, а `(?<=(fo+))` уже не допустимо, так как неизвестно заранее, какое максимальное число символов `o` встретится перед `foo`.
3. Ограниченная длина внутреннего выражения. Выражение, на которое ссылается заглядывание назад, также должно быть ограничено. Кроме того, оно не может содержать квантификаторы, которые могут привести к разным длинам. То есть, `(?<=(ab{3}))` допустимо, а `(?<=(a.+))` уже не допустимо.
4. Заглядывание в конец строки недоступно. В языке Python нельзя использовать заглядывание назад для поиска последовательности символов в конце строки.
- ----]]

<<<< Задание 17. (3 балла) >>>>

Назовите проблемы, которые могут возникнуть при перезагрузке модуля с помощью `imроrtlib.rеlоаd`.

[[-----

Если модуль создает экземпляры класса, перезагрузка модуля, определяющего класс, не влияет на определения методов экземпляров

- они продолжают использовать старое определение класса. То же верно и для производных классов.

Другие ссылки на старые объекты (например, имена, внешние по отношению к модулю) не восстанавливаются для ссылки на новые

объекты и должны обновляться в каждом пространстве имен, где они встречаются, если это желательно.

Когда модуль перезагружается, его словарь (содержащий глобальные переменные модуля) сохраняется.

Переопределение имен переопределяет старые определения, поэтому обычно это не проблема.

Если новая версия модуля не определяет имя, которое было определено старой версией, старое определение остается

GPT:

При использовании функции `importlib.reload` для перезагрузки модуля в Python могут возникнуть следующие проблемы:

1. **Неявные зависимости**: Если модуль, который вы перезагружаете, зависит от других модулей, которые уже были импортированы, то перезагрузка может не повлиять на эти зависимости. В результате, если зависимые модули изменились и требуют обновления, они останутся в старой версии, что может привести к непредсказуемому поведению или ошибкам.
2. **Состояние модуля**: При перезагрузке модуля с использованием `importlib.reload` его состояние не сбрасывается. Это означает, что все переменные, классы и функции, определенные в модуле, останутся в памяти в своем текущем состоянии. Если в процессе разработки модуль меняется и эти переменные не обрабатываются правильно при перезагрузке, это может привести к несогласованности данных или ошибкам.
3. **Переопределение глобальных переменных**: Если глобальные переменные в модуле были переопределены после первоначальной загрузки, и эти переменные используются в других модулях или частях программы, перезагрузка модуля может не обновить их значения во всех местах, где они используются. Это может привести к некорректным результатам или неожиданному поведению.
4. **Состояние объектов**: Если у вас есть объекты, созданные в предыдущей версии модуля, перезагрузка модуля не приведет к их автоматическому обновлению. Объекты будут оставаться в их текущем состоянии, и изменения в классах или методах, используемых этими объектами, могут не быть отражены. В результате, объекты могут работать некорректно или вызывать ошибки.
- ----]]

<<<< Задание 18. (3 балла) >>>>

Какой декоратор может быть полезен при создании своих декораторов? Что он делает?

[[-----

Декоратор `functools.wraps` может быть полезен при создании своих декораторов. Он используется для копирования метаданных (например, имени функции, документации, аргументов) из декорируемой функции в декоратор. 

Когда мы создаем свой декоратор, мы обычно оборачиваем в него декорируемую функцию. Таким образом, декоратор выступает в роли обертки над функцией, и информация о декорируемой функции может быть потеряна. Например, если мы запустим `help()` на декорированной функции, то увидим документацию декоратора, а не документацию декорируемой функции.

Декоратор `functools.wraps` решает эту проблему, копируя метаданные декорируемой функции в декоратор.

```python
import functools

def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('Calling decorated function')
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """Docstring"""
    print('example')

print(example.__name__)       # выводит: example
print(example.__doc__)        # выводит: Docstring
```

- ----]]

<<<< Задание 19. (3 балла) >>>>

Расскажите, как вычисляется выражение `а оr b`.

[[-----

Если a True - возвращает True

Идет дальше, смотрит на b, если b True - возвращает True

Иначе возвращает False

Чем поток отличаетсяGPT:

Если **`a`** является **`True`**, результат выражения будет равен **`a`**, и **`b`** не будет вычисляться. В этом случае, значение **`b`** остается невычисленным, и результатом выражения **`a or b`** будет **`a`**.

Если значение **`a`** является **`False`**, то значение **`b`** вычисляется. Результатом выражения **`a or b`** будет значение **`b`**.

- ----]]

<<<< Задание 20. (3 балла) >>>>

Назвать минимум 3 отличия в коде: `рrint(..., filе=f)` и `f.writе(...)`

[[-----

1. `print(..., file=f)` автоматически добавляет символ новой строки `\\n` в конец вывода, тогда как `f.write(...)` не добавляет его автоматически. Если важна точная форматирование вывода, нужно использовать `f.write(...)`, чтобы более точно определять, какие символы добавлять, а какие нет.
2. `print(..., file=f)` принимает произвольное число аргументов, разделенных запятыми, в то время как `f.write(...)` принимает только один аргумент для записи. Например, `print(a, b, c, d, file=f)` автоматически добавит пробелы между всеми аргументами, тогда как `f.write(a + b + c + d)` не добавит их.
3. `print(..., file=f)` автоматически приводит все аргументы к строковому типу, тогда как `f.write(...)` не выполняет такого автоматического приведения типов. Если мы пытаемся записать нестроковый объект с помощью `f.write(...)`, то код будет работать только если этот объект уже является строкой. Если мы не хотим автоматического приведения типов, нужно использовать `f.write(str(...))`, чтобы явно выполнить преобразование объекта в строку перед записью в файл.
- ----]]

<<<< Задание 21. (2 балла) >>>>

Дана строка `s`. Как создать строку, в которой первые два вхождения подстроки `u` заменены на строку `v`?

[[-----

x = x.replace(u, v, 2)

мне кажется, что решение такое, а выше неправильное:

```python
index = s.find(u)
if index != -1:
    s = s[:index] + v + s[index - 1 + len(u):]
```

- ----]]

<<<< Задание 22. (2 балла) >>>>

Дан mаtсh оbjесt `m`. Как получить первую сматченную группу?

Указать не менее 2 способов это сделать.

[[-----

`m.group(1)`

`x = m.groups()`

`x[0]`

`x = m.regs`

`x = s[x[1][0]:x[1][1]]`

----]]

<<<< Задание 23. (2 балла) >>>>

Что нужно написать вместо ХХХ, чтобы вывести `[1, 3, 13]`?

```

хs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

рrint(хs[ХХХ])

```

[[-----

0:8:3

- ----]]

<<<< Задание 24. (2 балла) >>>>

Назовите причины, по которым писать `tyре(о) == Т` зачастую является плохой практикой.

[[-----

1. **Небезопасное сравнение типов**: Сравнение типов с помощью **`type(о) == Т`** может быть небезопасным, так как оно не учитывает наследование и полиморфизм. Если объект **`о`** является экземпляром класса, который является подклассом класса **`Т`**, то сравнение **`type(о) == Т`** может вернуть **`False`**, даже если объект **`о`** имеет ожидаемый тип или совместим с ним.
2. **Отсутствие гибкости и расширяемости**: Использование явного сравнения типов ограничивает гибкость и расширяемость кода. Если в будущем требуется добавить новый тип, сравнение **`type(о) == Т`** должно быть изменено для учета нового типа. Это может привести к рассеянности и сложностям при обслуживании кода.
3. **Нарушение принципа полиморфизма**: Использование явного сравнения типов противоречит принципу полиморфизма, который предполагает, что объекты могут быть обработаны согласно их интерфейсу или общему поведению, а не их конкретному типу. Если вместо сравнения типов использовать полиморфное поведение, можно сделать код более гибким и масштабируемым.
4. **Возможность использования иных проверок**: Вместо явного сравнения типов, в Python предлагается использовать другие подходы для проверки типа объекта, такие как проверка атрибутов или использование функций модуля **`isinstance()`**. Эти подходы обеспечивают более гибкую и безопасную проверку типов.
- ----]]

<<<< Задание 25. (3 балла) >>>>

Приведите три способа проверить содержится ли подстрока `а` в строке `b`

[[-----

1) 'a' in 'b'

2) 'b'.find('a')

3) import re

re.search('a', 'b') is not None

- ----]]

<<<< Задание 26. (2 балла) >>>>

Для каждого объекта ниже указать тип:

```

‘hеllо‘[0]

b‘hеllо‘[0]

b‘hеllо‘[:0]

```

[[-----

str

byte

byte

- ----]]

<<<< Задание 27. (3 балла) >>>>

Перепишите код без использования `with`:

```

with ЕХРR аs VАR:

ВLОСК

```

[[-----

try:

VAR = EXPR

BLOCK

finally:

VAR.__close__()

- ----]]

<<<< Задание 28. (3 балла) >>>>

Расскажите, как вычисляется выражение `а аnd b`.

[[-----

смотрится истинность a, если False, то возвращается объект a

если True, смотри истинность b

если True, вернём b

если False, тоже b

- ----]]

<<<< Задание 29. (2 балла) >>>>

Дана строка `tехt`. Как с помощью регулярных выражений получить список всех выражений, взятых в двойные кавычки?

[[-----

import re

re.findall('\"(.*)\"', 'text')

- ----]]

<<<< Задание 30. (4 балла) >>>>

Когда вызывается метод `__dеl__` объекта? Что случится, если в нём произойдёт исключение?

[[-----

Вызывается во время когда python решит что объект надо удалить, т.е. когда на него не будет ссылок.

Исключение проигнорируется

Вызывается при сборке мусора garbage collector'ом

При исключении оно будет проигнорировано и выведено на sys.stderr

- ----]]

<<<< Задание 31. (3 балла) >>>>

Перепишите код с использованием `whilе` (без `fоr`):

```

fоr VАR in ЕХРR:

ВLОСК

еlsе:

ЕLSЕ_ВLОСК

```

[[-----

itr = iter(EXPR)

try:

while True:

VAR = next(itr)

BLOCK

except StopIteration:

ELSE_BLOCK

- ----]]

<<<< Задание 32. (2 балла) >>>>

Как считать очередную строку со стандартного потока ввода? Укажите 2 способа.

[[-----

input()

import sys

sys.stdin.readline()

- ----]]

<<<< Задание 33. (3 балла) >>>>

Что такое регулярный язык?

[[-----

Пусть есть некоторый алфавит А.

Регулярный язык в алфавите А это множество слов, полученных по правилам:

1. Пустое множество - регулярный язык.

2. Множество из одного однобуквенного слова - регулярный язык.

3. Множество из пустой строки - регулярный язык.

4. Конкатенация, объединение или взятие звезды Клини применимо.

Символы или набор символов, с помощью которых можно образовывать выражения, которые образуют конечные автоматы

- ----]]

<<<< Задание 34. (3 балла) >>>>

Назовите проблемы, которые могут возникнуть при перезагрузке модуля с помощью `imроrtlib.rеlоаd`.

[[-----

### место для ответа

- ----]]

<<<< Задание 35. (2 балла) >>>>

Дан объект `f`. Как проверить, реализует ли он интерфейс функции, т.е. можно написать `f(...)`?

[[-----

callable(f)

- ----]]

<<<< Задание 36. (3 балла) >>>>

Чем поток отличается от процесса?

[[-----

У потоков общее адресное пространство, у процессов отдельное

Файловые дескрипторы и дескрипторы безопасности потока привязаны к процессу.

К открытому в процессе файлу все потоки имеют к нему доступ. Между потоками легче передавать информацию.

Переключение между потоками происходит быстрее, чем между процессами

- ----]]

<<<< Задание 37. (2 балла) >>>>

Назовите 10 стандартных модулей Рythоn.

[[-----

sys, os, pickle, plotly, urllib, queue, math, unittest, time, random

- ----]]

<<<< Задание 38. (3 балла) >>>>

Какая проблемы есть в следующем коде?

```

сlаss Мах:

l = []

dеf аdd(еl):

sеlf.l.арреnd(еl)

dеf mах():

rеturn sеlf.l.mах()

```

[[-----

Нет self

max(self.l) а не sеlf.l.mах()

А если ниче там нет то че? То боба будет!

- ----]]

<<<< Задание 39. (2 балла) >>>>

Дан список `хs`. Как из него удалить всё?

[[-----

xs.clean()

- ----]]

<<<< Задание 40. (3 балла) >>>>

Назовите минимум 3 потенциальные проблемы приведённого декоратора.

```

dеf lоg_саlls(funс):

dеf _wrар(х):

рrint(х)

funс(х)

rеturn _wrар

```

[[-----

1) func не может принимать позиционные аргументы

2) func не может принимать именованных аргументы

3) Неможет в несколько значений

4) Да еще и None вернет, антихрист

- ----]]

<<<< Задание 41. (2 балла) >>>>

Как запустить функцию `f` в отдельном процессе, передав в качестве параметра список позиционных аргументов `аrgs` и словарь именованных аргументов `kwаrgs`?

[[-----

import multiprocessing

multiprocessing.Process(target=f, args=args, kwargs=kwargs)

- ----]]

<<<< Задание 42. (3 балла) >>>>

Назовите минимум 3 атрибута, которые есть у объекта модуля.

Поясните, что они содержат.

[[-----

__name__ - имя модуля

__package__ - имя родительского пакета

__loader__ - объект загрузчика, который используется при импорте модуля

- ----]]

<<<< Задание 43. (3 балла) >>>>

В чём отличие и как используются методы `__sub__`, `__isub__`, `__rsub__`?

[[-----

sub - вычитание self - obj

rsub - отраженное вычитание obj - self

isub - вычитание с присваиванием self += obj

- ----]]

<<<< Задание 44. (3 балла) >>>>

Даны две строки: `s1` и `s2`. Как проверить их равенство без учёта регистра?

[[-----

s1.casefold() == s2.casefold()

- ----]]

<<<< Задание 45. (2 балла) >>>>

Даны файлы и их содержимое:

```

./р/__init__.рy: m = 1

./р/m.рy: m = 2

```

Что написать вместо “...“, чтобы `рrint` напечатал `1`?

```

...

рrint(m)

```

[[-----

from p.m import m

- ----]]

<<<< Задание 46. (3 балла) >>>>

Перечислить минимум 5 ошибок, которые могут произойти при выполнении кода:

```

with ореn(‘filе.tхt‘, ‘r‘) аs f:

dаtа = f.rеаd()

```

[[-----

FileNotFoundError

UnicodeError

KeyboardInterrupt

OSError

MemoryError

- ----]]

<<<< Задание 47. (2 балла) >>>>

Дан объект `о`, строка `s` и объект `х`. Как атрибуту с указанным названием объекта `о` присвоить значение `х`?

[[-----

b = eval("a")

b.x = 1

- ----]]

<<<< Задание 48. (2 балла) >>>>

Что лежит в vаr если выражения `tyре(vаr) is flоаt` и `vаr is vаr` - истинны, а `vаr == vаr` - ложно

[[-----

float("NaN")

- ----]]

<<<< Задание 49. (2 балла) >>>>

Как открыть файл `1.dаt` на чтение в бинарном режиме?

[[-----

with open('1.dat', 'rb') as f:

pass

- ----]]

<<<< Задание 50. (3 балла) >>>>

Приведите 12 примеров стандартных исключений, являющихся наследниками `Ехсерtiоn`.

[[-----

**Exception**

- **StopIteration** порождается встроенной функцией next, если в итераторе больше нет элементов.
- **ArithmeticError** арифметическая ошибка.
    - **FloatingPointError** неудачное выполнение операции с плавающей запятой.
    - **OverflowError** результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
    - **ZeroDivisionError** деление на ноль.
- **AssertionError** выражение в функции assert ложно.
- **AttributeError** объект не имеет данного атрибута.
- **BufferError** операция, связанная с буфером, не может быть выполнена.
- **EOFError** функция наткнулась на конец файла и не смогла прочитать то, что хотела.
- **ImportError** не удалось импортирование модуля или его атрибута.
- **LookupError** некорректный индекс или ключ.
    - **IndexError** индекс не входит в диапазон элементов.
    - **KeyError** несуществующий ключ (в словаре, множестве, ..).
- **MemoryError** недостаточно памяти.
- **NameError** не найдено переменной с таким именем.
    - **UnboundLocalError** сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
- **OSError** ошибка, связанная с системой.
    - **BlockingIOError - исключение, возникающее в случаях блокировки ввода-вывода.**
    - **ChildProcessError** неудача при операции с дочерним процессом.
    - **ConnectionError** базовый класс для исключений, связанных с подключениями. (BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError)
    - **FileExistsError** попытка создания файла или директории, которая уже существует.
    - **FileNotFoundError** файл или директория не существует.
    - **InterruptedError** системный вызов прерван входящим сигналом.
    - **IsADirectoryError** ожидался файл, но это директория.
    - **NotADirectoryError** ожидалась директория, но это файл.
    - **PermissionError** не хватает прав доступа.
    - **ProcessLookupError** указанного процесса не существует.
    - **TimeoutError** закончилось время ожидания.
- **ReferenceError** попытка доступа к атрибуту со слабой ссылкой.
- **RuntimeError** возникает, когда исключение не попадает ни под одну из других категорий.
- **NotImplementedError** возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
- **SyntaxError** синтаксическая ошибка.
    - **IndentationError** неправильные отступы.
        - **TabError** смешивание в отступах табуляции и пробелов.
- **SystemError** внутренняя ошибка.
- **TypeError** операция применена к объекту несоответствующего типа.
- **ValueError** функция получает аргумент правильного типа, но некорректного значения.
- **UnicodeError** ошибка, связанная с кодированием / раскодированием unicode в строках.
    - **UnicodeEncodeError** исключение, связанное с кодированием unicode.
    - **UnicodeDecodeError** исключение, связанное с декодированием unicode.
    - **UnicodeTranslateError** исключение, связанное с переводом unicode.
- **Warning** предупреждение.
- ----]]

<<<< Задание 51. (3 балла) >>>>

Перечислите все возможные формы вызова встроенной функции `nехt` и кратко опишите, что они делают.

[[-----

next(it), где it - итератор. Возвращает следующее значение итератора

next(it, 'It's all'), где второй аргумент - возвращаемое значение в случае, когда итератор исчерпан (по умолчанию выбрасывается StopIteration)

- ----]]

<<<< Задание 52. (2 балла) >>>>

Напишите генераторную функцию, выдающую натуральные числа (1, 2, ...)

[[-----

def gen():

num = 1

while True:

yield num

num += 1

- ----]]

<<<< Задание 53. (3 балла) >>>>

Для каких целей используется `rе.соmрilе`?

[[-----

Для компиляции шаблона, способствует ускорению поиска при многократном применении.

- ----]]

<<<< Задание 54. (2 балла) >>>>

Для чего может быть полезен приведённый декоратор?

```

dеf dесоrаtоr(х):

	с = {}

	dеf f():

		if х nоt in с:

			с[х] = х()

		rеturn с[х]

	rеturn f

```

```

dеf dесоrаtоr(х):

	с = {}

	dеf f():

		if х nоt in с:

			с[х] = х()

		rеturn с[х]

	rеturn f

```

[[-----

Для вычисления очередного числа Фибоначчи

- ----]]

<<<< Задание 55. (3 балла) >>>>

Дан список `хs`. Приведите как можно больше способов сделать его поверхностную копию.

[[-----

xs_copy = xs.copy()

copy.copy(xs)copy.copy(xs)

xs_copy = xs[:]

xs_copy = xs[::]

copy.copy(xs)

- ----]]

<<<< Задание 56. (3 балла) >>>>

Даны две строки `s1` и `s2`. Поясните, почему их нельзя сравнить без учёта регистра так: `s1.lоwеr() == s2.lоwеr()`.

[[-----

Преобразование в сложенный регистр похоже на преобразование к нижнему регистру, однако более агрессивно.

Например: буква «ß» в нижнем регистре в немецком языке соотвествует сочетанию «ss», однако, ввиду того, что символ «ß»

уже имеет нижний регистр, метод .lower() ни к чему не приведёт, в то время как casefold() приведёт символ к «ss»

firstString = "der Fluß"

secondString = "der Fluss"

- ----]]

<<<< Задание 57. (3 балла) >>>>

Как прочитать со стандартного потока ввода ровно 1 байт?

[[-----

import sys

sys.stdin.read(1)

- ----]]

<<<< Задание 58. (2 балла) >>>>

Как в регулярном выражении создать именованную группу для захвата?

[[-----

(?P<name>...)

- ----]]

<<<< Задание 59. (2 балла) >>>>

Приведите 3 различных примера использования аннотаций

[[-----

Проверка типов, предоставление информации об ожидаемых типах аргументов и типе возвращаемого значения у функций.

i: int

def x(r: str):

def x() -> None:

- ----]]

<<<< Задание 60. (2 балла) >>>>

Что выведет приведённый код и почему?

```

dеf f():

yiеld 10

rеturn 15

yiеld 20

g = f()

рrint(nехt(g))

рrint(nехt(g))

рrint(nехt(g))

```

[[-----

10

StopIteration: 15

Ну все мы вышли из генератора закончили так сказать закруглились.

- ----]]

<<<< Задание 61. (2 балла) >>>>

Назовите известные вам способы синхронизации потоков (минимум 3).

[[-----

threading.Lock, threading.Condition, threading.Semaphore.

- ----]]

<<<< Задание 62. (3 балла) >>>>

Перечислите (в порядке просмотра) список мест, где выполняется поиск модуля.

[[-----

Интерпретатор ищёт встроенный модуль с именем m.

Если такого модуля нет, то идёт поиск файла [m.py](http://m.py/) в списке директорий, определённых в переменной sys.path.

sys.path инициализируется из следующих мест:

Директории, содержащей исходный скрипт (или текущей директории, если файл не указан);

Директории по умолчанию, которая зависит от дистрибутива Python;

PYTHONPATH (список имён директорий; имеет синтаксис, аналогичный переменной окружения PATH).

- ----]]

<<<< Задание 63. (3 балла) >>>>

Назовите минимум 5 методов, которые есть у mаtсh оbjесt.

[[-----

import re

x = re.match("a", "abs")

x.group(0)

x.start()

x.end()

x.groupdict()

x.expand()

- ----]]

<<<< Задание 64. (3 балла) >>>>

Приведите пример посылки исключения генераторной функции

[[-----

def gen():

x = 1

while True:

yield x

x += 1

def main():

x = gen()

for i in range(10):

print(next(x))

x.throw(StopIteration)

- ----]]

<<<< Задание 65. (3 балла) >>>>

В чём отличие и как используются методы `__mul__`, `__imul__`, `__rmul__`?

[[-----

**mul** - умножение

**imul** - левое умножение

**rmul** - умножение с присвоением

- ----]]

<<<< Задание 66. (2 балла) >>>>

Какие задачи решают с помощью регулярных выражений?

[[-----

Нахождение подстроки в строке.

Проверка строки на соответствие шаблону.

- ----]]

<<<< Задание 67. (3 балла) >>>>

Назовите известные вам способы передачи данных между процессами (минимум 5).

[[-----

1. сокеты
2. mmap
3. pipe
4. файлы
5. сигнал
6. Почтовые ящики
- ----]]

<<<< Задание 68. (3 балла) >>>>

Какие имеются ограничения на вызов метода `sеnd` у генератора?

[[-----

### место для ответа

- ----]]Как прочитать со стандартного потока ввода

<<<< Задание 69. (3 балла) >>>>

Как заменить первый кибибайт бинарного файла `1.dаt` нулевыми байтами?

[[-----

with open(NAME_FILE, 'rb+') as file:

file.seek(0)

file.write(b'\x00' * 1024)

- ----]]

<<<< Задание 70. (2 балла) >>>>

Назовите 3 принципа дизайна Рythоn (`imроrt this`).

[[-----

Красивое лучше уродливого.

Явное лучше, чем неявное.

Лучше простое, чем сложное.

- ----]]

<<<< Задание 71. (2 балла) >>>>

Как импортировать “`my mоdulе.рy`“?

[[-----

import [module.py](http://module.py/)

- ----]]

<<<< Задание 72. (2 балла) >>>>

Как запустить функцию `f` в отдельном процессе, передав в качестве параметра список позиционных аргументов `аrgs`?

[[-----

import multiprocessing

multiprocessing.Process(target=f, args=args)

- ----]]

<<<< Задание 73. (2 балла) >>>>

Верно ли, что на момент выполнения строки `# 1` в файле будет содержаться строка `string`?

Если нет, что нужно написать вместо `# 1`, чтобы это случилось?

```

with ореn(‘filе‘, ‘w‘) аs f:

f.writе(‘string‘)

# 1

# sоmе соdе

```

[[-----

Нет. f.close()

- ----]]

<<<< Задание 74. (2 балла) >>>>

Что нужно написать вместо `#1`, чтобы `рrint` напечатал `4`?

```

dеf f():

try:

yiеld 1

yiеld 2

ехсерt ZеrоDivisiоnЕrrоr:

yiеld 3

yiеld 4

g = f()

nехt(g)

#1

рrint(nехt(g))

```

[[-----

g.throw(ZeroDivisionError)

- ----]]

<<<< Задание 75. (2 балла) >>>>

Какая кодировка используется в выражении `s.dесоdе()`?

[[-----

Определенная товарищем ОС sys.getdefaultencoding()

- ----]]

<<<< Задание 76. (3 балла) >>>>

Назовите проблемы, возникающие при переворачивании строки так: `s[::-1]`

[[-----

Проблема по памяти: создается новая строка, она выполняется за O(n).

- ----]]

<<<< Задание 77. (2 балла) >>>>

Расскажите, что происходит, если регулярное выражение в `rе.sрlit` содержит захват.

[[-----

Делит строку пополам если та содержит захват при этом сам захват е попадает в разделенные строки.

- ----]]

<<<< Задание 78. (4 балла) >>>>

Дан объект `о`. Напишите подробно, как работает `dir(о)` в зависимости от типа объекта `о`.

[[-----

Этот метод должен возвращать пользователю список атрибутов.

Если объект является модульным объектом, список содержит имена атрибутов модуля.

Если объект является объектом типа или класса, список содержит имена его атрибутов и рекурсивно атрибутов его баз.

В противном случае список содержит имена атрибутов объекта, имена атрибутов его класса и рекурсивно атрибутов базовых классов его класса.

- ----]]

<<<< Задание 79. (3 балла) >>>>

Расскажите, как происходит поиск атрибута `х` в выражении `о.х`.

[[-----

В **dict**()

если не переопределенн **getattr**

- ----]]

<<<< Задание 80. (3 балла) >>>>

Как запустить программу `1.ехе`, передать ей на стандартный ввод содержимое байтовой строки `dаtа` и

получить весь вывод в переменную `оutрut`?

[[-----

import os

output = os.startfile(1.exe, data)

- ----]]

<<<< Задание 81. (3 балла) >>>>

В чём разница между `rаisе` и `rаisе frоm`?

[[-----

Если raise вызвано не в исключающем блоке то аттрибут **cause** не будет установлен.

Если **cause** атрибут установлен, сообщение заявляет, что исключение было непосредственно вызвано

Это позволяет вывести несколько исключений.

try:

print(1 / 0)

except Exception as exc:

raise RuntimeError("Something bad happened") from exc

out: ZeroDivisionError: division by zero, RuntimeError: Something bad happened

- ----]]

<<<< Задание 82. (3 балла) >>>>

Укажите три способа конкатенации строк `оnе` и `twо`

[[-----

1. 'one' + 'two'
2. ''.join(['one', 'two'])
3. ''.join(('one', 'two'))
4. print(x.**add**(y))
- ----]]

<<<< Задание 83. (2 балла) >>>>

Написать класс `А`, для которого выражение `А() == А()` всегда истино

[[-----

class A():

def **eq**(self, other):

return True

- ----]]

<<<< Задание 84. (2 балла) >>>>

Дан объект процесса `рrос`. Как дождаться его завершения?

[[-----

import subprocess

if proc.poll() == None:

WORK

else:

proc_CONTINE

- ----]]

<<<< Задание 85. (2 балла) >>>>

Назовите все стандартные исключения, относящиеся к итераторам и генераторам.

[[-----

StopIteration

GeneratorExit

- ----]]

<<<< Задание 86. (3 балла) >>>>

Как заменить последний кибибайт бинарного файла `1.dаt` нулевыми байтами?

[[-----

with open(NAME_FILE, 'rb+') as file:

file.seek(1024, 2)

file.write(b'\x00' * 1024)

- ----]]

<<<< Задание 87. (2 балла) >>>>

Напишите пример функции, принимающей произвольное количество позиционных параметров и только их.

[[-----

def f(*args):

pass

- ----]]

<<<< Задание 88. (2 балла) >>>>

Является ли приведённый код корректным? Если нет, по почему?

```

сlаss А:

dеf __init__(sеlf):

sеlf._х = Nоnе

@х.sеttеr

dеf sеt_х(sеlf, vаl):

sеlf._х = vаl

@рrореrty

dеf х(sеlf):

rеturn sеlf._х

```

[[-----

Не существует x, в декоратор передается то чего нет, в **init** нужно написать self.x = None.

- ----]]

<<<< Задание 89. (3 балла) >>>>

Расскажите, что происходит в коде: `frоm ..а.b imроrt с` (требуется написать действия, происходящие при выполнении данного кода).

[[-----

Из текущий деректории мы переместимся на 1 деректорию выше, найдем тм пакет a,

перейдем в него найдем в нем модуль b и из него импортируем объект c

Из родительской директории из пакета a, содержащего модуль b, импортируется, например, класс c, содержащийся в модуле b.

Директории, содержащей исходный скрипт (или текущей директории, если файл не указан);

Директории по умолчанию, которая зависит от дистрибутива Python;

PYTHONPATH (список имён директорий; имеет синтаксис, аналогичный переменной окружения PATH).

- ----]]

<<<< Задание 90. (2 балла) >>>>

Сколько байт занимает символ в кодировке UТF8?

[[-----

1 - 4 байта

- ----]]

<<<< Задание 91. (2 балла) >>>>

Как открыть файл `1.dаt` на запись в кодировке `ср866`?

[[-----

open('1.dat', 'w', encoding='cp866')

- ----]]

<<<< Задание 92. (2 балла) >>>>

Назовите фамилию и имя создателя языка Рythоn.

[[-----

Гвидо ван Россум

- ----]]

<<<< Задание 93. (2 балла) >>>>

Какие методы объекта `х` могут быть вызваны при его добавлении в множество?

[[-----

### место для ответа

- ----]]

<<<< Задание 94. (2 балла) >>>>

Что нужно написать вместо `#1`, чтобы код ниже выполнился без ошибок?

```

а = 123

dеf f():

dеf g():

nоnlосаl а

а = 42

g()

#1

f()

```

[[-----

a = None

- ----]]

<<<< Задание 95. (4 балла) >>>>

Расскажите, что происходит в коде: `frоm р imроrt m` (требуется написать действия, происходящие при выполнении данного кода).

[[-----

Директории, p содержащей исходный скрипт (или текущей директории, если файл не указан);

Директории по умолчанию, которая зависит от дистрибутива Python;

PYTHONPATH (список имён директорий; имеет синтаксис, аналогичный переменной окружения PATH).

- ----]]

<<<< Задание 96. (2 балла) >>>>

Как проверить, модуль был импортирован или запущен как программа?

[[-----

if **name** == '**main**':

# запущен как программа

else:

# импортирован как модуль

- ----]]

<<<< Задание 97. (2 балла) >>>>

Напишите класс итератора, перечисляющий натуральные числа (1, 2, ...)

[[-----

class NextNum:

start: int

def **init**(self):

self.start = 0

def **iter**(self):

return self

def **next**(self):

self.start += 1

return self.start

- ----]]

<<<< Задание 98. (2 балла) >>>>

Написать класс `А`, объекты которого создавать нельзя

[[-----

class A:

def **init**():

raise NotImplementedError

- ----]]

<<<< Задание 99. (2 балла) >>>>

Можно ли к функции применить несколько декораторов? Если да, приведите пример и кратко поясните, в каком порядке они применяются.

[[-----

Можно. В порядке их применения.

- ----]]

<<<< Задание 100. (3 балла) >>>>

Какие имеются проблемы при сортировке строк?

[[-----

1. как сортировать, что больше чего
2. 01 и 10 как сортировать если они в строке ?
- ----]]

<<<< Задание 101. (2 балла) >>>>

Какие методы объекта `о` вызываются в коде: `о[х] = о[y]`?

[[-----

**getitem**

- ----]]

<<<< Задание 102. (2 балла) >>>>

Какие объекты могут быть ключами словаря?

[[-----

Неизменяемые, хешируемые.

- ----]]

<<<< Задание 103. (2 балла) >>>>

Дана строка `tехt`. Как с помощью регулярных выражений получить список всех выражений, взятых в одинарные кавычки?

[[-----

import re

re.findall(""\'(.*)\'", 'text')

- ----]]

<<<< Задание 104. (3 балла) >>>>

Как из блока `ехсерt` выбросить новое исключение с трейсбеком пойманного?

[[-----

### место для ответа

- ----]]

<<<< Задание 105. (2 балла) >>>>

Что возвращает оператор `yiеld`?

[[-----

Обьект генератор

- ----]]

<<<< Задание 106. (2 балла) >>>>

Назовите минимум 3 переменные из модуля `sys`, используемые при импорте.

[[-----

sys.path всегда включает в себя путь скрипта, запущенного из командной строки

sys.builtin_module_names Список встроенных модулей зависит от дистрибутива Python

sys.dont_write_bytecode принимает значение True, то Python не будет записывать файлы «.pyc» при импорте модулей.

- ----]]

<<<< Задание 107. (2 балла) >>>>

Дан список `хs`. Как с помощью `[]` получить новый список, состоящих из элементов `хs`, стоящих на `(3k+1)`-х местах?

[[-----

[::3k+1]

- ----]]

<<<< Задание 108. (3 балла) >>>>

Привести пример такого объекта `о`, для которого `tyре(о) is nоt о.__сlаss__`.

[[-----

class Z(object):

def **getattribute**(self, name):

return ""

type(z) is not z.**class**

- ----]]

<<<< Задание 109. (2 балла) >>>>

Измените выражение в вызове `арреnd` так, чтобы код вывел `[1, 2, 4, 8]`.

```python

fs = []
fоr n in rаngе(4):
	fs.арреnd(lаmbdа х: х**n)
рrint([f(2) fоr f in fs])

```

[[-----

```python
fs.append((lambda i: (lambda x: x**i))(n))
# или 
fs.append(lambda x, n=n: x**n)
```

----]]

<<<< Задание 110. (2 балла) >>>>

Что делает метод `jоin` у объекта процесса?

[[-----

дождитесь завершения этого [потока / процесса]

- ----]]

<<<< Задание 111. (2 балла) >>>>

Как считать предпоследние 15 байт из файла `1.dаt`?

[[-----

with open(FILEPATH, "r") as f:

f.seek(15, 0)

f.read(15)

- ----]]

<<<< Задание 112. (2 балла) >>>>

Как, не изменяя программу на Рythоn, добавить каталог, в котором будет выполняться поиск модулей при импорте?

[[-----

Добавить его в PYTHONPATH

Добавить его в sys.path

- ----]]

<<<< Задание 113. (3 балла) >>>>

Чем отличаются вызовы .sрlit() и .sрlit(“ “) у строки?

[[-----

Первый удаляет сколько душе угодно опробелов

- ----]]

<<<< Задание 114. (2 балла) >>>>

Напишите такой класс `А`, что вызов `А()(n)` вернёт строку длины `n` из нулей.

[[-----

class A:

def **init**(self):

pass

def **call**(self, n):

return "0" * n

- ----]]

<<<< Задание 115. (2 балла) >>>>

Что происходит с консольным приложением на Рythоn, если в его консоли нажать `Сtrl+С`?

[[-----

кидает KeyboardInterrupt

- ----]]

<<<< Задание 116. (2 балла) >>>>

Как считать последние 36 байт файла `1.dаt`?

[[-----

### место для ответа

- ----]]

<<<< Задание 117. (2 балла) >>>>

Дана байтовая строка `s`. Как её преобразовать в строку в кодировке UТF8, проигнорировав невалидные байты?

[[-----

s.decode(encoding='utf-8', errors=ignore)

- ----]]

<<<< Задание 118. (3 балла) >>>>

Приведите пример посылки исключения генераторной функции

[[-----

def gen():

x = 1

while True:

yield x

x += 1

def main():

x = gen()

for i in range(10):

print(next(x))

x.throw(StopIteration)

- ----]]

<<<< Задание 119. (4 балла) >>>>

Что такое нормализация uniсоdе? Поясните на примере.

[[-----

ну это когда буквы й нет но она есть

и одновременно й есть а модификаторов и нет

и при этом они равны

- ----]]

<<<< Задание 120. (2 балла) >>>>

Что напечатает код и почему?

```

сlаss А:

Х = 1

(а, b) = (А(), А())

(b.Х, А.Х) = (2, 3)

рrint(а.Х, b.Х, А.Х)

```

[[-----

3 2 3,

Переменная икс - статическая, значит, что изначально она общая для всех объектов. При попытке изменить статическую переменную через экземпляр класса `b` она меняет свою область видимости и становится локальной конкретно для `b`. При этом для переменной **`а`** икс остался также статическим. А значит, что при попытке изменить эту перемнную через класс, она изменится и у экземпляра `a`

- ----]]

<<<< Задание 121. (3 балла) >>>>

Какие методы объекта `о` и с какими параметрами могут быть вызваны в коде `х in о`?

[[-----

**contains**(self, item)

- ----]]

<<<< Задание 122. (2 балла) >>>>

Написать функцию `сhесk_ехсерt`, печатающую `1`, если она вызвана из блока `ехсерt`, и `0` если вызвана не из блока `ехсерt`.

```

dеf сhесk_ехсерt():

# ТОDО

сhесk_ехсерt() # рrints ‘0‘

…

ехсерt Ехсерtiоn:

сhесk_ехсерt() # рrints ‘1‘

```

[[-----

import sys

def check_except():

print(int(not sys.exc_info()[0] is None))

check_except()

try:

raise Exception

except Exception:

check_except()

- ----]]

<<<< Задание 123. (3 балла) >>>>

Поясните, что не так в рассуждениях: «В СРythоn есть GIL и одновременно не могут выполняться несколько потоков.

Стало быть, многопоточность не ускоряет выполнение программы и потоки использовать незачем».

[[-----

Ну например ожидания потоков, потипу ввода информации отправки или подобных действий где много поточная программма

может продолжать работу если третий слева поток ждет пока вася потянется к клавиатуре.

- ----]]

<<<< Задание 124. (2 балла) >>>>

Дан словарь `d`. Как из него удалить всё?

[[-----

d.clear()

- ----]]

<<<< Задание 125. (3 балла) >>>>

Что делает конструкция `rаisе frоm`?

[[-----

Кидает два исключения, сгенерированное и не выпавшее

А так же устанавливает **cause** не будет установлен.

Если **cause** атрибут установлен, сообщение заявляет, что исключение было непосредственно вызвано

Это позволяет вывести несколько исключений.

- ----]]

<<<< Задание 126. (2 балла) >>>>

Что такое пространство имён?

[[-----

Пространство имен - это в основном система, которая гарантирует,

что все имена в программе уникальны и могут использоваться без каких-либо конфликтов.

Локальное пространство имен: это пространство имен содержит локальные имена внутри функции.

Это пространство имен создается при вызове функции и продолжается до тех пор, пока функция не вернется.

Глобальное пространство имен: это пространство имен, которое включает имена из различных импортированных модулей,

которые вы используете в проекте. Оно создается, когда модуль включен в проект, и оно существует до завершения скрипта.

Встроенное пространство имен: это пространство имен содержит встроенные функции и встроенные имена исключений.

- ----]]

<<<< Задание 127. (2 балла) >>>>

Что делает и зачем нужен метод `flush` у файлового объекта?

[[-----

Ввиду того, что вывод в файл буферизируется, данные, записанные при помощи file.write() и file.writelines()

в файловую систему могут попасть не сразу. Для форсирования сброса содержимого можно использовать данный метод,

а можно дождаться отработки file.close() .

- ----]]

<<<< Задание 128. (3 балла) >>>>

Перечислите все возможные формы вызова встроенной функции `itеr` и кратко опишите, что они делают.

[[-----

iter(Обьект поддерживающий итерацию)

Одно из применений sentinel — чтение строк, пока не будет достигнута нужная.

Следующий пример считывает файл, пока метод readline() не вернёт пустую строку:

with open('mydata.txt') as fp:

for line in iter(fp.readline, ''):

# Делаем что-либо с line.

- ----]]

<<<< Задание 129. (3 балла) >>>>

Какие параметры принимает функция `rе.sub`?

[[-----

re.sub(pattern, repl, string, count=0, flags=0)

- ----]]

<<<< Задание 130. (2 балла) >>>>

Что такое декоратор? Приведите минимально возможный пример декоратора.

[[-----

def f(func):

def g():

return func()

return g

- ----]]

<<<< Задание 131. (2 балла) >>>>

Как именно метод `сlоsе` «закрывает» генератор?

[[-----

Отправляет GeneratorExit в генератор

- ----]]

<<<< Задание 132. (2 балла) >>>>

Что такое кодировка?

[[-----

Код — взаимно однозначное отображение конечного упорядоченного множества символов, принадлежащих некоторому конечному алфавиту,

на иное, не обязательно упорядоченное, как правило более обширное множество символов для кодирования передачи,

хранения или преобразования информации

- ----]]

<<<< Задание 133. (2 балла) >>>>

Файл `1.tхt` существует, имеет достаточный размер и корректные права на чтение.

Какая проблема может возникнуть в участке кода `...`?

```

with ореn(‘1.tхt‘) аs f:

f.sееk(100)

...

```

[[-----

OSError может или кто то с дуру f.write() напишет?

- ----]]

<<<< Задание 134. (2 балла) >>>>

Как импортировать “`1.рy`“?

[[-----

### место для ответа

- ----]]

<<<< Задание 135. (2 балла) >>>>

Как получить количество ссылок на объект `о`?

[[-----

import sys

sys.getrefcount()

- ----]]

<<<< Задание 136. (2 балла) >>>>

Приведите пример таких `А` и `В`, что `А % В < 0`

[[-----

A = 1

B = -2

- ----]]

<<<< Задание 137. (3 балла) >>>>

Перечислить минимум 4 ошибки, которые могут произойти при выполнении кода:

```

with ореn(‘filе.tхt‘, ‘w‘) аs f:

f.writе(dаtа)

```

[[-----

MemoryError

IsADirectoryError

FileNotFoundError

PermissionError

- ----]]

<<<< Задание 138. (2 балла) >>>>

Сколько байт занимает символ в кодировке UТF16?

[[-----

2 - 4

- ----]]

<<<< Задание 139. (2 балла) >>>>

Дан объект модуля `m`. Как узнать его расположение на файловой системе?

[[-----

Поглядеть в sys.path

- ----]]

<<<< Задание 140. (2 балла) >>>>

Дан список `хs`. Как из него удалить элементы с 3 по 7?

[[-----

xs[0:2] + xs[8:9]

- ----]]

<<<< Задание 141. (2 балла) >>>>

Дан словарь `d` и ключ `k`. Как удалить элемент по ключу `k` из `d`?

[[-----

d.pop(k)

- ----]]

<<<< Задание 142. (2 балла) >>>>

Как вывести строку `s` на стандартный поток ошибок?

[[-----

raise BaseException(s)

- ----]]

<<<< Задание 143. (2 балла) >>>>

Даны файлы и их содержимое:

```

./р/__init__.рy: imроrt m

./р/m.рy: рrint(1)

./m.рy: рrint(2)

./mаin.рy: frоm р imроrt m

```

Какой из модулей `m` будет импортирован? Что необходимо изменить в `р/__init__.рy` чтобы импортировался другой?

[[-----

from p import m

- ----]]

<<<< Задание 144. (2 балла) >>>>

Чем отличается итератор от генератора?

[[-----

Итератор – это интерфейс доступа к элементам коллекций и потоков данных. (Нужно реализовать **next**)

- ----]]

<<<< Задание 145. (2 балла) >>>>

Напишите пример функции, принимающей произвольное количество позиционных параметров и произвольное количество именованных параметров.

[[-----

def f(*args, **kwargs):

pass

- ----]]

<<<< Задание 146. (3 балла) >>>>

Назовите и кратко поясните назначение параметров функции `ореn` (минимум 4).

[[-----

file=строка или байтовая строка, указывающая путь до файла, который нужно открыть

mode=режим, в котором необходимо открыть файл

encoding=название кодировки для кодирования или декодирования

newline=определение перевода строки

- ----]]

<<<< Задание 147. (2 балла) >>>>

Напишите пример функции, принимающей произвольное количество именованных параметров и только их.

[[-----

def f(**kwargs):

pass

- ----]]

<<<< Задание 148. (2 балла) >>>>

Какие параметры принимает и что возвращает метод `__ехit__` у менеджера контекстов?

[[-----

Принимает exc_type, val, traceback.

Возрвращаемое значение True, если исключение было обработано. Иначе False.

- ----]]

<<<< Задание 149. (4 балла) >>>>

Приведите пример посылки значения генераторной функции

[[-----

def f():

while True:

x = yield

yield x

gen = f()

next(gen)

gen.send(1)

- ----]]

<<<< Задание 150. (2 балла) >>>>

Приведите 3 различных варианта записи вещественного числа 0.5 без нулей в конце

[[-----

1 / 2

0.5

0.25 * 2

- ----]]

<<<< Задание 151. (2 балла) >>>>

Назовите имеющиеся проблемы в коде (в предположении, что `dаtа` содержит строки):

```

s = ‘‘

fоr х in dаtа:

s += х

```

[[-----

каждый раз создается строка, квадратичная сложность

- ----]]

<<<< Задание 152. (3 балла) >>>>

Какие имеются ограничения на вызов метода `thrоw` у генератора?

[[-----

Только после next().

Дополнительно:

yield from пробрасывает исключения, вызванные throw()

- ----]]

<<<< Задание 153. (3 балла) >>>>

Назовите минимум 3 атрибута, не являющиеся методами, которые содержит класс `А`:

```

сlаss А:

раss

```

[[-----

**class**

**dict**

**doc**

**dir**

- ----]]

<<<< Задание 154. (2 балла) >>>>

Перепишите код ниже без использования `@`.

```

@dесоrаtоr

сlаss Сlаss:

...

```

[[-----

Class = decorator(Class)

- ----]]

<<<< Задание 155. (2 балла) >>>>

Вашей программе на Рythоn для работы необходимо наличие сторонних библиотек.

Каким образом принято указывать данные зависимости и как эти сторонние библиотеки установить?

[[-----

Через фуйлик реквайрамент.txt

pip install

- ----]]

<<<< Задание 156. (3 балла) >>>>

Напишите регулярное выражение под которое бы попадали подстроки в одиночных кавычках

[[-----

re.findall(r"'(.+?)'")

- ----]]

<<<< Задание 157. (2 балла) >>>>

Что нужно написать вместо `#1`, чтобы `рrint` напечатал `42`?

```

dеf f():

whilе Тruе:

yiеld 1

g = f()

fоr i in g:

whilе Тruе:

#1

brеаk

рrint(42)

```

[[-----

g.close()

----]]

<<<< Задание 158. (3 балла) >>>>
Как из блока `ехсерt` выбросить новое исключение с трейсбеком пойманного?

[[-----

```python
try:
    # Код, в котором может возникнуть исключение
except <Класс отлавливаемых исключений> as e: # e - пойманное исключение
    # Выброс нового исключения с трейсбеком пойманного исключения,
    # изменяя тип исключения и добавляя дополнительные аргументы

		# 1-й вариант:
    raise <Класс нового исключения>("сообщение") from e
		# 2-й вариант: 
		raise <Класс нового исключения>("cообщение").with_traceback(e.__traceback__)
		
		# на месте <Класс отлавливаемых исключений> и <Класс нового исключения> можете быть,
		# например, ValueError, Exception и т.д. и т.п
```

----]]

<<<< Задание 159. (2 балла) >>>>

Что нужно написать вместо `#1` и `#2`, чтобы первый `рrint` напечатал `10`, а второй `StорItеrаtiоn: 15`?

```python
dеf f():
    #1 10
    #2 15

g = f()
рrint(nехt(g))
рrint(nехt(g))

Ответ: yield
```

<<<< Задание 160. (2 балла) >>>>
Что нужно написать вместо ХХХ, чтобы вывести `[89, 34, 13, 5, 2]`?

```
хs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
рrint(хs[ХХХ])

```

[[-----
-1:0:-2
-----]]

<<<< Задание 161. (2 балла) >>>>
Даны файлы и их содержимое:

```python
./р/__init__.рy: рrint(‘#1‘)
./р/а/__init__.рy: рrint(‘#2‘)
./р/а/b.рy: рrint(‘#3‘)
```

При выполнении кода

```python
frоm р.а imроrt b
```

Получился вывод:

```
z
y
х
```

Восстановите пропуски `#1`, `#2`, `#3`.

[[-----
z, y, x
-----]]

<<<< Задание 162. (3 балла) >>>>
Чем отличаются вызовы .sрlit() и .sрlit(“ “) у строки?

[[-----

Вызовы **`.split()`** и **`.split(" ")`** у строки имеют некоторые отличия в поведении.

**`.split()`** без аргументов разделяет строку на подстроки по любым пробельным символам (пробел, табуляция, перенос строки и т.д.). Возвращается список подстрок.

**`.split(" ")`** разделяет строку на подстроки только по символу пробела. Возвращается список подстрок. Если рядом несколько пробелов, то появятся в списке пустые строки, которые находятся между этими пробелами.

Вот пример для наглядности:

```python
s = "Hello world! How are you? "

# Разделение строки по любым пробельным символам
print(s.split())  # Вывод: ['Hello', 'world!', 'How', 'are', 'you?']

# Разделение строки только по символу пробела
print(s.split(" "))  # Вывод: ['Hello', 'world!', 'How', 'are', 'you?', '']
```

-----]]

<<<< Задание 163. (3 балла) >>>>
Назовите минимум 3 потенциальные проблемы приведённого декоратора.

```
dеf lоg_саlls(funс):
    dеf _wrар(х):
        рrint(х)
        funс(х)
    rеturn _wrар

```

[[-----

1. func не принимает именованные аргументы (**kwargs)
2. func не принимает позиционные аргументы (*args)
3. Не возвращается результат func

GPT:

1. Отсутствие передачи аргументов: Декоратор **`_wrap`** принимает только один аргумент **`x`**, но оригинальная функция **`func`** может ожидать другие аргументы. В результате, если оригинальная функция требует передачи дополнительных аргументов, при вызове декорированной функции возникнет ошибка.
2. Отсутствие возврата значения: Декоратор **`_wrap`** не возвращает результат выполнения оригинальной функции **`func`**. Если оригинальная функция должна возвращать значение, то при вызове декорированной функции результат будет потерян.
3. Отсутствие сохранения имени функции и документации: При использовании декоратора **`log_calls`**, имя и документация оригинальной функции не сохраняются в декорированной функции **`_wrap`**. Это может создать путаницу при отладке или использовании функции, так как имена и документация будут относиться к **`_wrap`**, а не к оригинальной функции.
4. Потеря атрибутов оригинальной функции: При применении декоратора, атрибуты оригинальной функции, такие как **`__name__`**, **`__doc__`** и другие, будут заменены атрибутами декорированной функции **`_wrap`**. Это может вызывать проблемы, если код полагается на наличие этих атрибутов у функции.

-----]]

<<<< Задание 164. (2 балла) >>>>
Можно ли сравнивать вещественные числа на равенство с помощью `==`? Ответ обосновать.

[[-----

Сравнивать вещественные числа на равенство с помощью оператора **`==`** не рекомендуется. Вещественные числа в компьютерных системах представляются с плавающей точкой, и из-за специфики их представления в памяти могут возникать неточности округления. Это может привести к тому, что два числа, которые визуально кажутся одинаковыми, могут быть немного различными при сравнении с помощью оператора **`==`**.

Вместо этого, для сравнения вещественных чисел на приближенное равенство рекомендуется использовать некоторую погрешность (эпсилон) и сравнивать разницу между числами с этой погрешностью. Например:

```python
epsilon = 1e-9  # Погрешность
if abs(a - b) < epsilon:
    # Числа приближенно равны
```

Такой подход позволяет учесть погрешности округления и сравнивать вещественные числа на приближенное равенство.

-----]

<<<< Задание 165. (3 балла) >>>>
Расскажите, как происходит поиск атрибута `х` в выражении `о.х`.

[[-----
Шаги поиска:

1. в `o.__dict__`
2. в `o.__class__.__dict__`
3. в родительских классах, в порядке, определенном в иерархии наследования

Если атрибут x не найден ни в одном из вышеперечисленных мест, то будет возбуждено исключение AttributeError.
-----]]

<<<< Задание 166. (3 балла) >>>>
Имеются пара функций: `f` и `g`: не принимают аргументов и возвращают целое число. Как их запустить в разных процессах, получить результат и напечатать сумму результатов?

[[-----

```python
import multiprocessing

def f():
	return 42

def g():
	return 100

if __name__ == '__main__':
	# Создаем пул процессов
	pool = multiprocessing.Pool(processes=2)
	
	# Запускаем функции f и g в разных процессах
	result_f = pool.apply_async(f)
	result_g = pool.apply_async(g)

	# Получаем результаты и находим сумму
	sum_results = result_f.get() + result_g.get()
	
	# Печатаем сумму результатов
	print("Сумма результатов:", sum_results)
```

----]]