# Алгоритмы

- Алгоритм (Борувки, Каскл) - Каскала
    
    > Алгоритм Борувки-Каскала находит минимальное остовное дерево в связном взвешенном графе. Он состоит из нескольких фаз, на каждой из которых выбираются ребра, включаемые в остовное дерево. На первой фазе выбираются минимальные ребра, инцидентные каждой вершине. На последующих фазах выбираются минимальные ребра, соединяющие компоненты, которые были получены на предыдущих фазах. Алгоритм завершается, когда все вершины становятся связанными.
    > 
    
    Пошаговый алгоритм:
    
    1. Создать список компонентов, начально каждая вершина является отдельной компонентой.
    2. Для каждой компоненты выбрать минимальное ребро, инцидентное ей.
    3. Объединить компоненты, соединенные выбранными ребрами.
    4. Повторять шаги 2-3, пока остается более одной компоненты.
    
    Когда все вершины становятся связанными, алгоритм завершается и остовное дерево графа готово.
    
    Сложность алгоритма Борувки-Каскала составляет O(E log V), где E - количество ребер, V - количество вершин в графе.
    
- Алгоритм (Янник, Прим, Дейкстра) - Дейкстры
    
    > Алгоритм Янника-Прима-Дейкстры находит минимальное остовное дерево в связном взвешенном графе. Он начинается с произвольной вершины графа и далее на каждом шаге добавляется ребро с минимальным весом, инцидентное уже построенному дереву. Алгоритм завершается, когда все вершины становятся связанными.
    > 
    
    Пошаговый алгоритм:
    
    1. Выбрать произвольную вершину графа.
    2. Из всех ребер, инцидентных выбранной вершине, выбрать ребро с минимальным весом.
    3. Добавить выбранное ребро в остовное дерево.
    4. Повторять шаги 2-3 для каждой новой вершины, добавленной в остовное дерево, до тех пор, пока все вершины не будут связаны.
    
    Когда все вершины становятся связанными, алгоритм завершается и остовное дерево графа готово.
    
    Сложность алгоритма Янника-Прима-Дейкстры зависит от реализации очереди с приоритетами. В случае использования кучи (heap), которая обеспечивает доступ к минимальному элементу за O(1), сложность алгоритма составляет O(E log V), где E - количество ребер, V - количество вершин в графе. Если же использовать неэффективную реализацию очереди с приоритетами, например, массив с линейным поиском минимального элемента, то сложность алгоритма может достигать O(V^2).
    

***Основное отличие первого алгоритма (Борувки-Каскала) от второго (Янника-Прима-Дейкстры) заключается в том, как они выбирают ребра для включения в остовное дерево. В Борувки-Каскала на каждой фазе выбираются минимальные ребра, инцидентные каждой вершине. В Янника-Прима-Дейкстры на каждом шаге выбирается минимальное ребро, инцидентное уже построенному дереву.***

- Алгоритм Дейкстры (решение задачи МаксМин)
    
    > Для решения задачи МаксМин, необходимо найти максимальное минимальное расстояние между любыми двумя вершинами графа. Для этого можно использовать алгоритм Дейкстры для нахождения кратчайших путей от каждой вершины до всех остальных вершин. Затем, для каждой вершины, выбираем минимальное из найденных расстояний и находим максимальное из полученных значений. Это и будет максимальное минимальное расстояние в графе.
    > 
    
    Пошаговый алгоритм:
    
    1. Инициализировать массив расстояний dist[] бесконечно большими значениями, кроме расстояния до начальной вершины, которое равно 0.
    2. Создать очередь с приоритетом, в которую положить начальную вершину с расстоянием dist[start] = 0.
    3. Извлечь вершину с наименьшим расстоянием из очереди и для каждого соседа обновить расстояние до него, если новое значение меньше текущего.
    4. Если расстояние до какой-то вершины обновилось, и добавить ее в очередь с приоритетом.
    5. Повторять шаги 3-4, пока очередь не станет пустой.
    6. Для каждой вершины выбрать минимальное из найденных расстояний и найти максимальное из полученных значений. Это и будет максимальное минимальное расстояние в графе.
    
    Важно отметить, что если в графе есть ребра отрицательного веса, то нужно использовать модифицированный алгоритм Дейкстры, который способен работать с такими графами. Если же в графе есть циклы отрицательного веса, то ни один из этих алгоритмов не даст корректного результата.
    
    Сложность алгоритма Дейкстры зависит от реализации очереди с приоритетами. В случае использования кучи (heap), которая обеспечивает доступ к наименьшему элементу за O(1), сложность алгоритма составляет O(E log V), где E - количество ребер, V - количество вершин в графе. Если же использовать неэффективную реализацию очереди с приоритетами, например, массив с линейным поиском минимального элемента, то сложность алгоритма может достигать O(V^2).
    
- Модифицированный алгоритм Дейкстры
    
    Модифицированный алгоритм Дейкстры используется для нахождения кратчайших путей от одной вершины до всех остальных вершин в графе с отрицательными весами ребер. Он работает следующим образом:
    
    1. Инициализируем расстояния от исходной вершины до всех остальных вершин как бесконечность, кроме исходной вершины, у которой расстояние равно 0.
    2. Создаем очередь с приоритетами, в которую кладем исходную вершину.
    3. Извлекаем вершину из очереди с наименьшим расстоянием и для каждого ее соседа обновляем расстояние до него, если новое значение меньше текущего.
    4. Если расстояние до какой-то вершины обновилось, кладем ее в очередь с приоритетами.
    5. Повторяем шаги 3-4, пока очередь не станет пустой.
    
    Важно отметить, что если в графе есть циклы отрицательного веса, то этот алгоритм может не дать корректного результата, так как расстояния до некоторых вершин будут стремиться к минус бесконечности.
    
    Сложность модифицированного алгоритма Дейкстры зависит от реализации очереди с приоритетами. В случае использования кучи (heap), которая обеспечивает доступ к минимальному элементу за время O(1) и вставку нового элемента за время O(log n), сложность алгоритма составляет O(m log n), где m - количество ребер, а n - количество вершин в графе. Если вместо кучи использовать простой массив и проходить по нему каждый раз при извлечении минимального элемента, то сложность алгоритма составит O(n^2).
    
- Алгоритм Флойда-Уоршелла (решение задачи нахождения кратчайшего пути между всеми парами вершин)
    
    > Для решения этой задачи можно использовать алгоритм Флойда-Уоршелла. Он находит кратчайшие расстояния между всеми парами вершин в графе. Алгоритм можно описать следующим образом:
    > 
    1. Инициализировать матрицу расстояний dist[n][n] так, чтобы dist[i][j] содержало вес ребра между вершинами i и j, если такое ребро есть, иначе бесконечность.
    2. Для каждой вершины i, для каждой вершины j, для каждой вершины k, если dist[i][k] + dist[k][j] меньше, чем текущее значение dist[i][j], то обновляем его.
        1. Для i от 1 до n
        2. Для j от 1 до n
        3. Для k от 1 до n
        4. Если dist[i][k] + dist[k][j] меньше, чем текущее значение dist[i][j], то обновляем его.
    3. Когда все пары вершин будут обработаны, матрица dist будет содержать кратчайшие расстояния между всеми парами вершин.
    
    Важно отметить, что алгоритм Флойда-Уоршелла работает за время O(n^3), где n - количество вершин в графе. Если граф очень большой, то может потребоваться использовать альтернативные алгоритмы для нахождения кратчайших путей, например, алгоритм Джонсона.
    
- Алгоритм Тарьяна (поиск компонент сильной связности)
    
    Алгоритм Тарьяна используется для нахождения компонент сильной связности в ориентированном графе. Он работает следующим образом:
    
    1. Обход каждой вершины графа в глубину, запоминая время захода в каждую вершину и наименьшее время захода в вершины, достижимые из данной вершины (lowlink).
    2. Помещаем вершины в стек в порядке, обратном времени их завершения обхода.
    3. Для каждой вершины, достигнутой из текущей вершины, устанавливаем ее lowlink равным минимальному из ее lowlink и lowlink текущей вершины.
    4. Если текущая вершина является корнем компоненты сильной связности (т.е. первой в данной компоненте, которая посещается), то извлекаем вершины из стека, начиная с текущей, и помещаем их в новую компоненту сильной связности.
    5. Повторяем шаги 1-4 для всех вершин графа.
    
    В результате выполнения алгоритма получается разбиение графа на компоненты сильной связности.
    
    Сложность алгоритма Тарьяна составляет O(|V| + |E|), где |V| и |E| - количество вершин и ребер в графе соответственно.
    
- Алгоритм Форда-Белмана
    
    > Алгоритм Форда-Беллмана используется для поиска кратчайших путей в графе, возможно с отрицательными весами ребер. Вот пошаговый алгоритм на примере неориентированного графа:
    > 
    1. Установить расстояние от начальной вершины до всех остальных вершин, кроме самой начальной, равным бесконечности. Расстояние от начальной вершины до самой начальной равно 0.
    2. Повторять шаги 3-5 n-1 раз, где n - количество вершин в графе.
    3. Проходить по всем ребрам графа. Если текущее расстояние до вершины u + вес ребра до вершины v меньше, чем текущее расстояние до вершины v, то обновить расстояние до вершины v.
    4. После обновления расстояний до всех вершин, проверить наличие отрицательного цикла в графе. Для этого повторить проход по всем ребрам и проверить, есть ли вершина, для которой расстояние до нее можно уменьшить. Если такая вершина найдена, то в графе есть отрицательный цикл.
    5. Если отрицательный цикл найден, то алгоритм завершается, иначе переходим к следующей итерации.
    6. Если проход по всем вершинам n-1 раз не выявил отрицательного цикла, то кратчайшие расстояния до всех вершин найдены.
    7. Для получения кратчайшего пути от начальной вершины до любой другой вершины можно использовать массив предшествующих вершин, который заполняется в процессе работы алгоритма.

# Решения задач

- Борьба со шпионажем
    
    Данная задача является задачей о нахождении минимального остовного дерева взвешенного графа, где вес ребра соответствует вероятности передачи информации между сотрудниками.
    
    Алгоритм Прима позволяет решить эту задачу за O(n^2) времени. Он заключается в следующих шагах:
    
    1. Инициализировать список вершин, которые еще не включены в остовное дерево, и произвольную стартовую вершину.
    2. Для каждой вершины, кроме стартовой, найти ребро минимального веса, соединяющее ее с уже включенными вершинами.
    3. Добавить вершину с минимальным найденным ребром в остовное дерево.
    4. Повторять шаги 2 и 3 до тех пор, пока все вершины не будут включены в остовное дерево.
    
    В конечном итоге, полученное остовное дерево будет являться минимальным, то есть обеспечивать минимальную вероятность утечки информации.
    
- Автобусные маршруты
    
    Для решения задачи необходимо использовать алгоритм поиска кратчайшего пути в невзвешенном графе, так как стоимость всех ребер равна 1. Для этого можно использовать алгоритм обхода в ширину (BFS).
    
    Алгоритм будет работать следующим образом:
    
    1. Стартовой точкой будет место, где находится команда из города Петюки.
    2. Для каждой остановки на каждом маршруте, которые соединены с начальной точкой, запускается BFS, чтобы найти наименьшее количество пересадок для каждой остановки.
    3. Поиск продолжается до тех пор, пока не будут найдены все возможные конечные точки на маршрутах в городе Васюки.
    4. Среди всех найденных конечных точек выбирается та, у которой наименьшее количество пересадок.
    5. По найденным остановкам на маршрутах ведется поиск маршрута с помощью алгоритма поиска кратчайшего пути взвешенного графа, например, алгоритм Дейкстры.
    
    Сложность алгоритма будет O(N^2), где N - количество автобусных маршрутов в городе Васюки.
    
- Дейкстра вместо Форда-Беллмана
    
    Алгоритм Дейкстра действительно может дать неправильный результат, если в графе есть ребра отрицательного веса. Рассмотрим следующий пример:
    
    ```
        (1) --2--> (2)
         |        / |
        1|      /   |3
         |    /     |
         v  v      v
        (3) --4--> (4)
    ```
    
    Предположим, что мы хотим найти кратчайший путь из вершины 1 в вершину 4. Если бы у нас не было отрицательных ребер, то алгоритм Дейкстра работал бы корректно и нашел бы кратчайший путь 1 -> 2 -> 4 длиной 5.
    
    Однако в этом графе есть ребро отрицательного веса (2 -> 3). Если мы запустим алгоритм Дейкстра, то он сначала выберет вершину 1, затем вершину 2 и обновит расстояние до вершины 3 до -1. Затем он выберет вершину 3 и обновит расстояние до вершины 4 до 3. Таким образом, алгоритм Дейкстра даст нам неправильный результат и выберет путь 1 -> 3 -> 4 длиной 3, хотя на самом деле кратчайший путь имеет длину 5.
    
    Для решения таких задач можно использовать алгоритм Беллмана-Форда или алгоритм Флойда-Уоршелла, которые работают с графами с ребрами отрицательного веса.
    
- Дорожное управление
    
    Эта задача соответствует задаче о минимальном остовном дереве в теории графов. Цель заключается в том, чтобы найти минимальный набор ребер, который соединяет все вершины графа без циклов.
    
    Для решения этой задачи можно использовать алгоритм Прима или алгоритм Крускала. Оба алгоритма относятся к жадным алгоритмам и на каждом шаге выбирают ребро с минимальным весом, которое ещё не добавлено в остовное дерево.
    
- Открытие чемпионата мира по программированию
    
    Для данной задачи можно использовать теорию ориентированных графов. Каждое выступление можно представить вершиной, а порядок выступлений - ребрами. Таким образом, задача сводится к нахождению топологической сортировки в данном графе.
    
    Алгоритм нахождения топологической сортировки:
    
    1. Выберем любую вершину, не имеющую входящих ребер (таких вершин может быть несколько).
    2. Добавим эту вершину в список результата и удалим ее из графа вместе со всеми исходящими из нее ребрами.
    3. Повторяем шаги 1-2 для оставшихся вершин до тех пор, пока все вершины не будут добавлены в список результата или пока не будет обнаружен контур в графе (в этом случае топологическая сортировка невозможна).
    
    Таким образом, порядок выступлений будет определяться в соответствии с порядком вершин в списке результата, полученном в результате топологической сортировки. Если в графе присутствуют контуры, то выступления находящиеся внутри контура будут конфликтными и их порядок будет произвольным.
    
- Деревенские автобусы
    
    Данная задача является задачей о кратчайшем пути на графе, где вершинами являются деревни, а ребрами - автобусные рейсы между деревнями. Вес ребра соответствует времени, необходимому для проезда по данному рейсу.
    
    Для решения этой задачи можно использовать алгоритм Дейкстры. Необходимо поддерживать множество посещенных вершин и множество непосещенных вершин. Для каждой вершины необходимо хранить ее расстояние от начальной вершины А (изначально равно бесконечности) и предыдущую вершину в кратчайшем пути от начальной вершины.
    
    Алгоритм Дейкстры заключается в следующем:
    
    1. Установить расстояние от начальной вершины А равным 0 и добавить ее в множество непосещенных вершин.
    2. Для каждой вершины v из множества непосещенных вершин найти ее соседей и обновить их расстояния и предыдущую вершину, если новый путь короче старого.
    3. После обновления всех соседей поместить текущую вершину в множество посещенных вершин и удалить ее из множества непосещенных вершин.
    4. Повторять шаги 2-3 до тех пор, пока все вершины не будут посещены.
    
    После выполнения алгоритма Дейкстры, кратчайший путь от начальной вершины А до конечной вершины Б можно восстановить, используя информацию о предыдущих вершинах в кратчайшем пути.
    
- День объединения
    
    Да, можно решить эту задачу как задачу на нахождение минимального остова. Для этого нужно построить граф, в котором вершинами будут острова, а ребрами - мосты. Весом каждого ребра будет являться год его постройки.
    
    Затем нужно применить алгоритм нахождения минимального остова, например, алгоритм Крускала или алгоритм Прима. Это позволит найти минимальный набор мостов, которые соединяют все острова между собой.
    
    Когда все острова будут соединены мостами, значит, наступил день объединения, и можно найти год этого события, как год постройки последнего моста, входящего в минимальный остов.
    
- Сдача с доллара
    
    Жадный алгоритм может не дать оптимального решения в случае, когда для набора монет существует такой набор монет меньшего количества, который в совокупности дает ту же сумму. Примером такого набора может быть следующий:
    
    Предположим, что у нас есть набор монет {1, 3, 4}, и мы хотим набрать сумму в 6 центов. Жадный алгоритм выберет первым максимальный достоинством монету 4, затем 1 и еще одну 1, что дает в сумме 3 монеты. Однако, оптимальным решением будет выбор монет 3 и 3, что даст в сумме только 2 монеты.
    
    Таким образом, жадный алгоритм не всегда дает оптимальное решение для задачи нахождения наименьшего количества монет для набора заданной суммы.
    
- Телефонная станция
    
    Эта задача соответствует задаче о минимальном остовном дереве (Minimum Spanning Tree, MST) на графе. Алгоритм, который следует применить, зависит от размера графа и требуемой производительности. Для небольших графов можно использовать алгоритм Прима или алгоритм Крускала. Для больших графов можно использовать алгоритм Борувки.
    
    Чтобы связать каждый дополнительный центр связи с основным, необходимо найти минимальное остовное дерево на графе, где узел 1 является корневым узлом. В результате применения алгоритма MST получим множество ребер, которые нужно использовать для соединения дополнительных центров связи с основным центром. Конкретные узлы связи, между которыми следует проложить кабель, будут соответствовать ребрам в минимальном остовном дереве.
    
- Церемония вручения дипломов
    
    Для решения данной задачи можно использовать алгоритм топологической сортировки. Алгоритм работает на графе, где вершины представляют собой события, а дуги между вершинами указывают на зависимости между событиями. Зависимости могут быть двух видов: событие A должно быть выполнено до начала события B (направленная дуга от A к B), или события A и B могут быть выполнены в любом порядке (ненаправленная дуга между A и B).
    
    Алгоритм топологической сортировки заключается в следующем:
    
    1. Выполнить поиск в глубину (DFS) в графе событий, сохраняя время окончания обработки каждой вершины.
    2. Расположить вершины в порядке убывания времени окончания обработки (от последнего к первому).
    3. Перебирать вершины в упорядоченном списке и добавлять их в отсортированный список, пропуская те вершины, которые уже были добавлены.
    
    В нашем случае, можно использовать список мероприятий, предшествующих и последующих, как список вершин графа. Зависимости между событиями можно задать направленными дугами от событий, которые должны быть выполнены раньше, к событиям, которые должны быть выполнены позже.
    
    Алгоритм определения порядка событий:
    
    1. Создать граф событий, где вершины - это мероприятия, а дуги указывают на зависимости между мероприятиями.
    2. Применить алгоритм топологической сортировки к графу.
    3. Получить отсортированный список мероприятий в порядке, определенном алгоритмом топологической сортировки. Этот список будет представлять оптимальный порядок проведения мероприятий.
- Катаем кубик
    
    Для решения этой задачи можно построить граф, где вершины соответствуют полям доски, а рёбра соединяют вершины, соответствующие полям, на которых может оказаться кубик после перекатывания. Вес ребра между вершинами (i, j) будет равен числу, написанному на грани кубика, соответствующей полю j. Таким образом, задача сводится к поиску пути на графе с минимальной суммой весов рёбер.
    
    Для решения этой задачи можно использовать алгоритм Дейкстры или алгоритм Беллмана-Форда. Оба алгоритма позволяют находить кратчайшие пути в графе с неотрицательными весами рёбер. Если веса рёбер могут быть отрицательными, то следует использовать алгоритм Форда-Беллмана или алгоритм Джонсона.
    
    Алгоритм Дейкстры имеет временную сложность O(N^2), где N - количество вершин в графе. Однако, если использовать мин-кучу для хранения кандидатов на следующую вершину, то сложность алгоритма можно уменьшить до O(M log N), где M - количество рёбер в графе.
    
    Алгоритм Беллмана-Форда имеет временную сложность O(NM), где M - количество рёбер в графе. Однако, если использовать очередь с приоритетами для хранения кандидатов на следующую вершину, то сложность алгоритма можно уменьшить до O(M log N).
    
    Таким образом, если использовать алгоритм Дейкстры с мин-кучей, то сложность алгоритма будет O(M log N), что является оптимальным решением.
    
- Метро не в Екатеринбурге
    
    Данная задача является задачей о минимальном остовном дереве на графе, где вершинами являются острова, а ребрами - мосты или тоннели между ними.
    
    Математическая модель:
    Пусть дан неориентированный взвешенный граф G=(V, E), где V - множество вершин (островов), E - множество ребер (мостов и тоннелей). Вес каждого ребра соответствует стоимости строительства метро между двумя островами. Требуется найти минимальное остовное дерево (МОД) этого графа, т.е. такое подмножество ребер, которое содержит все вершины графа и связано только ребрами, вес которых минимален.
    
    Алгоритм решения:
    Один из наиболее эффективных алгоритмов решения задачи о минимальном остовном дереве - алгоритм Крускала.
    
    1. Сортируем все ребра графа по весу.
    2. Начинаем со связного пустого графа и поочередно добавляем к нему ребра с наименьшим весом, при этом не допуская образования циклов.
    3. Повторяем пункт 2 до тех пор, пока не будут добавлены все вершины графа или пока остаются только вершины, которые не могут быть связаны.
    
    Сложность алгоритма Крускала составляет O(E log E), где E - количество ребер в графе. В данной задаче количество ребер может быть не более, чем квадратичным от количества вершин, то есть O(V^2), поэтому сложность алгоритма составляет O(V^2 log V^2), что можно упростить до O(V^2 log V).
    
- Кратчайший путь
    
    Рассмотрим граф на рисунке ниже:
    
    ```
      2     1
    S --> A --> T
     \     ^
      5   / 3
       \ /
        B
        |
        4
        |
        C
    ```
    
    В этом графе алгоритм может найти неоптимальный путь от S до T. Алгоритм начнет с вершины S и добавит вершины {A, B} в P, полагая предшественниками A и B вершину S. Затем алгоритм выберет ребро с наименьшим весом из ребер (A, T) и (B, T), то есть ребро (B, T) с весом 3. Алгоритм добавит вершину T в P и положит предшественником T вершину B. Поскольку T теперь включена в P, алгоритм остановится и вернет путь S->B->T, который имеет длину 5+3=8.
    
    Однако, оптимальный путь от S до T - это S->A->T, который имеет длину 2+1=3.
    
    Чтобы найти кратчайший путь от S до T в этом графе, можно использовать алгоритм Дейкстры или алгоритм Беллмана-Форда.
    
- Коррупция
    
    Да, задачу можно решить с помощью алгоритма Тарьяна. Для этого нужно построить ориентированный граф, где вершинами будут сенаторы, а ребрами будут отношения "имеет компромат на". Затем применить алгоритм Тарьяна для нахождения компонент сильной связности в графе.
    
    Сенаторы, которые входят в компоненты сильной связности, содержащие больше чем одну вершину, могут в одиночку провести антигосударственный закон, и следовательно, они являются наиболее опасными.
    
    Если все компоненты сильной связности содержат только по одной вершине, то это означает, что ни один сенатор не может в одиночку принять антигосударственное решение, и следовательно, нет наиболее опасных сенаторов.
    
- Экономный маршрут
    
    Модель этой задачи как задача оптимизации на графе может быть представлена следующим образом:
    
    - Каждый город представляется вершиной графа, а дороги между городами - ребрами с весом, равным стоимости бензина.
    - Необходимо найти кратчайший путь между городом А и городом Б с учетом стоимости бензина.
    
    Для решения этой задачи можно использовать алгоритм Дейкстры. Он позволяет находить кратчайший путь от заданной вершины до всех остальных вершин во взвешенном графе. Алгоритм Дейкстры работает только для графов без отрицательных ребер.
    
    1. Инициализировать массив расстояний dist для каждой вершины, кроме стартовой, значением infinity (бесконечность), а расстояние до стартовой вершины - 0.
    2. Создать пустое множество посещенных вершин visited и добавить в него стартовую вершину.
    3. Для каждой соседней вершины v каждой вершины u, которая уже была посещена, обновить расстояние до v, если сумма расстояния от начальной вершины до u и вес ребра (u, v) меньше, чем текущее расстояние до v. Если расстояние до v было обновлено, то добавить v в множество посещенных вершин.
    4. Повторять шаг 3, пока все вершины не будут посещены.
    
    После выполнения алгоритма, расстояние от начальной вершины до каждой вершины графа будет содержаться в массиве dist. Чтобы найти самый экономный маршрут от А до Б, необходимо пройти по пути с минимальной суммой весов ребер.
    
- Вершинное покрытие
    
    Рассмотрим граф, представленный на рисунке ниже:
    
    ```
       1 --- 2 --- 3
       |     |     |
       4 --- 5 --- 6
    ```
    
    Пусть жадный алгоритм начнет с вершины 5, так как она имеет наибольшую степень. Затем он добавит вершину 2 и удаляет все смежные ребра, что приводит к покрытию {2, 5}. Однако оптимальное вершинное покрытие для этого графа равно {1, 4, 5}, что требует одну вершину больше, чем полученное жадным алгоритмом.